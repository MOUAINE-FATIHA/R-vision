PHP POO

ğŸŸ¦ Jour 4 : PHP POO - Classes & Objets

â—â€‹ Questions ThÃ©oriques :
1.â€‹ Quelle est la diffÃ©rence entre une classe et un objet ?
Une classe c'est un modÃ¨le ou un plan, elle dÃ©crit les attributs et les methodes d'un objet.
Un objet est une instance de cette classe, c-Ã -d une version rÃ©elle crÃ©Ã©e Ã  partir du modÃ¨le

2.â€‹ Ã€ quoi sert le mot-clÃ© $this ?
$this dÃ©signer l'objet actuel Ã  l'intÃ©rieur de la classe , il permet d'accÃ©der aux attributs et aux mÃ©thodes de l'objet courant.

3.â€‹ Quel est le rÃ´le du constructeur (__construct) ?
Le constructeur est une mÃ©thode spÃ©ciale qui s'exÃ©cute automatiquement quand on crÃ©e un objet , il sert Ã  initialiser les attributs de l'objet.


â—â€‹ Challenges Pratiques :
1.â€‹ Challenge 1 : CrÃ©er une classe Voiture avec 3 attributs (marque, modele,
vitesse) et une mÃ©thode accelerer() qui augmente la vitesse.

<?php

class Voiture {
    public $marque;
    public $modele;
    public $vitesse = 0 ;

    public function accelerer() {
        $this->vitesse +=10;
        echo "vitesse: " . $this->vitesse ;
    }
}

2.â€‹ Challenge 2 : Ajouter un constructeur Ã  la classe Voiture pour initialiser la
marque et le modÃ¨le lors de la crÃ©ation de l'objet.

<?php

class Voiture {
    public $marque;
    public $modele;
    public $vitesse = 0;

    public function __construct($marque, $modele) {
        $this->marque = $marque;
        $this->modele = $modele;
    }

    public function accelerer() {
        $this->vitesse +=10;
        echo "La voiture $this->marque a $this->vitesse km/h <br> " ;
    }
}

3.â€‹ Challenge 3 : Instancier deux objets de la classe Voiture et appeler leurs
mÃ©thodes pour vÃ©rifier leur fonctionnement.

$v1=new Voiture("Toyota","corolla");
$v2 =new Voiture("BMW","X5");

$v1->accelerer();
$v2->accelerer(); 

ğŸŸ¦ Jour 5 : PHP POO - Encapsulation
â—â€‹ Questions ThÃ©oriques :
1.â€‹ Quâ€™est-ce que lâ€™encapsulation ? Quel est son but ?
il sert de protÃ©ger les donnÃ©es d'une classe et contrÃ´ler leur accÃ¨s.

2.â€‹ Quelle est la diffÃ©rence entre public, private et protected ?
public: on peut accÃ©der Ã  l'attribut ou la mÃ©thode partout.
private: on peut accÃ©der Ã  les attributs dans la classe
protected: accessible dans la classe et dans les classes qui hÃ©ritent.

3.â€‹ Ã€ quoi servent les getters et setters ? Est-ce toujours nÃ©cessaire d'en avoir pour
chaque attribut ?
les getters servent Ã  rÃ©cupÃ©rer la valeur d'un attribut privÃ©,
et les setters servent Ã  modifier un attribut avec un contrÃ´le.
--> ils ne sont pas toujours obligatoires, mais ils sont trÃ¨s utiles quand on veut protÃ©ger les donnÃ©es ou vÃ©rifier les valeurs.


â—â€‹ Challenges Pratiques :
1.â€‹ Challenge 1 : Modifier la classe Voiture : mettre l'attribut vitesse en private.
class Voiture {
    public $marque;
    public $modele;
    private $vitesse= 0;
}

2.â€‹ Challenge 2 : CrÃ©er un getter getVitesse() et un setter setVitesse(int $v)
qui empÃªche d'assigner une vitesse nÃ©gative.

class Voiture {
    public $marque;
    public $modele;
    private $vitesse = 0;
    public function getVitesse(){
        return $this->vitesse;
    }
    public function setVitesse(int $v){
        if ($v >= 0) {
            $this->vitesse = $v;
        }else{
            echo "Vitesse incorrecte";
        }
    }
}

3.â€‹ Challenge 3 : CrÃ©er une classe CompteBancaire avec un attribut solde privÃ©.
ImplÃ©menter les mÃ©thodes deposer() et retirer() en s'assurant que le solde
ne puisse pas devenir nÃ©gatif.

class CompteBancaire {
    private $solde= 0 ;
    public function __construct($soldeInitial){
        $this->solde = $soldeInitial ;
    }
    public function deposer($montant){
        if($montant > 0){
            $this-> solde += $montant ;
        }
    }
    public function retirer($montant){
        if($montant > 0 && $montant <= $this->solde) {
            $this->solde -= $montant;
        }else{
            echo "le solde est trÃ©s petit";
        }
    }
    public function getSolde(){
        return $this->solde;
    }
}

