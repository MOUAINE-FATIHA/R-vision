PHP POO

ğŸŸ¦ Jour 4 : PHP POO - Classes & Objets

â—â€‹ Questions ThÃ©oriques :
1.â€‹ Quelle est la diffÃ©rence entre une classe et un objet ?
Une classe c'est un modÃ¨le ou un plan, elle dÃ©crit les attributs et les methodes d'un objet.
Un objet est une instance de cette classe, c-Ã -d une version rÃ©elle crÃ©Ã©e Ã  partir du modÃ¨le

2.â€‹ Ã€ quoi sert le mot-clÃ© $this ?
$this dÃ©signer l'objet actuel Ã  l'intÃ©rieur de la classe , il permet d'accÃ©der aux attributs et aux mÃ©thodes de l'objet courant.

3.â€‹ Quel est le rÃ´le du constructeur (__construct) ?
Le constructeur est une mÃ©thode spÃ©ciale qui s'exÃ©cute automatiquement quand on crÃ©e un objet , il sert Ã  initialiser les attributs de l'objet.


â—â€‹ Challenges Pratiques :
1.â€‹ Challenge 1 : CrÃ©er une classe Voiture avec 3 attributs (marque, modele,
vitesse) et une mÃ©thode accelerer() qui augmente la vitesse.

<?php

class Voiture {
    public $marque;
    public $modele;
    public $vitesse = 0 ;

    public function accelerer() {
        $this->vitesse +=10;
        echo "vitesse: " . $this->vitesse ;
    }
}

2.â€‹ Challenge 2 : Ajouter un constructeur Ã  la classe Voiture pour initialiser la
marque et le modÃ¨le lors de la crÃ©ation de l'objet.

<?php

class Voiture {
    public $marque;
    public $modele;
    public $vitesse = 0;

    public function __construct($marque, $modele) {
        $this->marque = $marque;
        $this->modele = $modele;
    }

    public function accelerer() {
        $this->vitesse +=10;
        echo "La voiture $this->marque a $this->vitesse km/h <br> " ;
    }
}

3.â€‹ Challenge 3 : Instancier deux objets de la classe Voiture et appeler leurs
mÃ©thodes pour vÃ©rifier leur fonctionnement.

$v1=new Voiture("Toyota","corolla");
$v2 =new Voiture("BMW","X5");

$v1->accelerer();
$v2->accelerer(); 

ğŸŸ¦ Jour 5 : PHP POO - Encapsulation
â—â€‹ Questions ThÃ©oriques :
1.â€‹ Quâ€™est-ce que lâ€™encapsulation ? Quel est son but ?
il sert de protÃ©ger les donnÃ©es d'une classe et contrÃ´ler leur accÃ¨s.

2.â€‹ Quelle est la diffÃ©rence entre public, private et protected ?
public: on peut accÃ©der Ã  l'attribut ou la mÃ©thode partout.
private: on peut accÃ©der Ã  les attributs dans la classe
protected: accessible dans la classe et dans les classes qui hÃ©ritent.

3.â€‹ Ã€ quoi servent les getters et setters ? Est-ce toujours nÃ©cessaire d'en avoir pour
chaque attribut ?
les getters servent Ã  rÃ©cupÃ©rer la valeur d'un attribut privÃ©,
et les setters servent Ã  modifier un attribut avec un contrÃ´le.
--> ils ne sont pas toujours obligatoires, mais ils sont trÃ¨s utiles quand on veut protÃ©ger les donnÃ©es ou vÃ©rifier les valeurs.


â—â€‹ Challenges Pratiques :
1.â€‹ Challenge 1 : Modifier la classe Voiture : mettre l'attribut vitesse en private.
class Voiture {
    public $marque;
    public $modele;
    private $vitesse= 0;
}

2.â€‹ Challenge 2 : CrÃ©er un getter getVitesse() et un setter setVitesse(int $v)
qui empÃªche d'assigner une vitesse nÃ©gative.

class Voiture {
    public $marque;
    public $modele;
    private $vitesse = 0;
    public function getVitesse(){
        return $this->vitesse;
    }
    public function setVitesse(int $v){
        if ($v >= 0) {
            $this->vitesse = $v;
        }else{
            echo "Vitesse incorrecte";
        }
    }
}

3.â€‹ Challenge 3 : CrÃ©er une classe CompteBancaire avec un attribut solde privÃ©.
ImplÃ©menter les mÃ©thodes deposer() et retirer() en s'assurant que le solde
ne puisse pas devenir nÃ©gatif.

class CompteBancaire {
    private $solde= 0 ;
    public function __construct($soldeInitial){
        $this->solde = $soldeInitial ;
    }
    public function deposer($montant){
        if($montant > 0){
            $this-> solde += $montant ;
        }
    }
    public function retirer($montant){
        if($montant > 0 && $montant <= $this->solde) {
            $this->solde -= $montant;
        }else{
            echo "le solde est trÃ©s petit";
        }
    }
    public function getSolde(){
        return $this->solde;
    }
}

ğŸŸ¦ Jour 9 : PHP POO - HÃ©ritage
â—â€‹ Questions ThÃ©oriques :
1.â€‹ Comment fonctionne lâ€™hÃ©ritage en POO ? Ã€ quoi sert extends ?
il permet Ã  une classe de reprendre les attributs et les mÃ©thodes d'une classe parent

2.â€‹ Quelle est la diffÃ©rence entre parent:: et self:: ?
self:: appeler une mÃ©thode ou attribut dans la mÃªme classe
parent:: appeler une mÃ©thode ou un constructeur de la classe parent

3.â€‹ Quel est l'impact de la visibilitÃ© protected dans le contexte de l'hÃ©ritage ?
si on a un attribut protected, c-Ã -d elle n'est pas accessible depuis l'extÃ©rieur de la classe, mais elle reste accessible dans les classes enfants

â—â€‹ Challenges Pratiques :
1.â€‹ Challenge 1 : CrÃ©er une classe Vehicule (attributs: marque, mÃ©thode:
demarrer()). CrÃ©er une classe Voiture qui hÃ©rite de Vehicule et ajoute un
attribut nombreDePortes.
class Vehicule{
    public $marque;
    public function __construct($marque) {
        $this->marque = $marque;
    }
    public function demarrer(){
        echo "dÃ©marre";
    }
}
class Voiture extends Vehicule {
    public $nombreDePortes;
    public function __construct($marque,$nombreDePortes) {
        parent::__construct($marque);
        $this->nombreDePortes = $nombreDePortes ;
    }
}

2.â€‹ Challenge 2 : Dans la classe Voiture, redÃ©finir la mÃ©thode demarrer() pour
qu'elle affiche "La voiture dÃ©marre" au lieu de "Le vÃ©hicule dÃ©marre".
class Voiture extends Vehicule  {
    public function demarrer(){
        echo"La voiture dÃ©marre";
    }
}

3.â€‹ Challenge 3 : CrÃ©er une classe Moto qui hÃ©rite aussi de Vehicule. Appeler le
constructeur du parent depuis le constructeur de Moto pour initialiser la
marque.
class Moto extends Vehicule {
    public function __construct($marque){
        parent::__construct($marque);
    }
}

ğŸŸ¦ Jour 10 : PHP POO - Abstraction

â—â€‹ Questions ThÃ©oriques :
1.â€‹ Quâ€™est-ce que lâ€™abstraction ?
c'est la crÃ©ation d'une classe qui sert comme modÃ¨le gÃ©nÃ©ral , elle permet de dÃ©finir des mÃ©thodes importantes que les classes enfants doivent obligatoirement implÃ©menter.

2.â€‹ Peut-on instancier une classe abstraite ? Pourquoi ?
non , la classe abstraite est seulement une base pour les classes filles elle contient souvent des mÃ©thodes abstraites qui ne sont pas encore dÃ©finies.

3.â€‹ Peut-on dÃ©clarer une mÃ©thode abstraite private ? Expliquez.
non, car la mÃ©thode abstraite doit Ãªtre redÃ©finie dans les classes enfants.

â—â€‹ Challenges Pratiques :
1.â€‹ Challenge 1 : CrÃ©er une classe abstraite Animal avec une mÃ©thode crier(). La
classe Animal ne peut pas Ãªtre instanciÃ©e.
abstract class Animal{
	abstract public function crier();
}

2.â€‹ Challenge 2 : CrÃ©er une classe Chien et une classe Chat qui hÃ©ritent d'Animal
et implÃ©mentent chacune leur propre version de la mÃ©thode crier().
class Chien extends Animal{
    public function crier(){
        echo "chien";
    }
}
class Chat extends Animal{
    public function crier(){
        echo"chat";
    }
}

3.â€‹ Challenge 3 : CrÃ©er une classe parente Employe avec une mÃ©thode abstraite
calculerSalaire(). CrÃ©er deux classes filles EmployeFixe et
EmployeCommission qui l'implÃ©mentent.

Classe abstraite Employe
abstract class Employe {
    public $nom;
    public function __construct($nom){
        $this->nom= $nom;
    }
    abstract public function calculerSalaire();
}

EmployeFixe
class EmployeFixe extends Employe{

    public $salaireFixe;
    public function __construct($nom, $salaireFixe) {
        parent::__construct($nom);
        $this->salaireFixe= $salaireFixe;
    }
    public function calculerSalaire(){
        return $this -> salaireFixe;
    }
}

EmployeCommission
class EmployeCommission extends Employe{
    public $ventes;
    public $tauxCommission;
    public function __construct($nom , $ventes , $tauxCommission) {
        parent::__construct($nom);
        $this -> ventes= $ventes;
        $this -> tauxCommission = $tauxCommission;
    }
    public function calculerSalaire(){
        return $this-> ventes * $this-> tauxCommission;
    }
}

